# **Intersect**

A compiled language that is **explicit and versatile**.

## How it works

**Intersect** compiles utilizing the *LLVMLite* python module by *Numba*.  It utilizes a complex concrete syntax tree to handle it's compile time mechanisms such as it's garbage collector, minimal function/struct emmitter and mangler, automatic typing, and much more.

## Language Conventions

### Comments

**Tarantula** uses cPython style comments:

```py
# This is a comment
```

### Capitalization

In **Tarantula**, keywords are explicitly named.  Ex:

```rust
struct StructName<TemplateType> {

    attribute:TemplateType;

    operator == (self:$StructName<TemplateType>, other:$StructName<TemplateType>) {
        return self.attribute == self.attribute;
    }
}
```

### Automatic And Manual Memory Management (Work in progress)

**Tarantula**'s automatic memory allocation is confined strictly to scope (more specifically to curly braces). `$` prefixes a *type* as a pointer type.  `heap` prefixes a *value* as a heap allocated value and allocates it on the heap.

```py
{
    let md_array: [$[i32]] = [
        heap [0,1,2],
        heap [0,1,2],
        heap [0,1,2]
    ];


    # md_array's heap allocated items are freed here
}
```

With the `persist` keyword, heap values can escape their scope, as exemplified below, but will need to be deleted manually eventually.

```py
# Create an array full of null pointers:
let outer_md_array: [$[i32 x 3] x 3] = []

{
    let md_array: [$[i32]] persist = [
        heap [0,1,2],
        heap [0,1,2],
        heap [0,1,2],
    ];

    outer_md_array[0] = md_array[0]
    outer_md_array[1] = md_array[1]
    outer_md_array[2] = md_array[2]
}

# All heap allocated items are freed here.
for (let i = 0; i < 3; i++) {
    delete outer_md_array[i]
}
```

You can either free each item of an object *manually as shown above*, or free the *entire object as shown below*:

```py
delete outer_md_array
```

***Keep in mind:*** freeing the entire array will call delete on every item of the array.  For structs, deleting the entire struct will call the `OPERATOR destructor` if it is implemented, if not it will free all heap members of the struct.

### Operator Macros (Work in progress)

Operator macros let you implement extra operators with explicit names for classes.  This allows for a more declarative syntax.

```rust
macro operator binary equals;

struct StructName<TemplateType> {

    data:TemplateType;

    operator equals (self:$StructName<TemplateType>, other:$StructName<TemplateType>) ~> bool {
        return self.data == self.data;
    }
}

func main() {
    let s1:StructName<i32>;
    let s2:StructName<i32>;
    s1.data = 1;
    s2.data = 1;

    libc_printf("equal operator result %i\n":$c8, s1 equals s2);
    return;
}
```

## Updates

### First Ever Tarantula Program Compiled!

The first ever **Tarantula** program was compiled today on `Saturday, November 18, 2023 at 8:20 P.M.`.  It doesnt do much, but it is *something!*

```rust
# test.pop

struct Vector<ItemType> {
    data:[ItemType x 5];
}

export func test(num: i32) {
    let my_vec:Vector<i32>;
    
    return;
}
```

Heres the *LLVM-IR* generated by compiling this program.

```llvm
; ModuleID = "./test.pop"
target triple = "unknown-unknown-unknown"
target datalayout = ""

%"Vector_struct_tmp_MMAANNGGLLEE_i32" = type {[5 x i32]}
declare i32 @"printf"(i8* %".1", ...)

declare i8* @"malloc"(i64 %".1")

declare i8* @"realloc"(i8* %".1", i64 %".2")

declare void @"free"(i8* %".1")

@"null" = global i8 0
define void @"test"(i32 %"num")
{
entry:
  %"my_vec" = alloca %"Vector_struct_tmp_MMAANNGGLLEE_i32"
  ; OP::define(stack) START
  ; OP::define(stack) END
  ; OP::return START
  ret void
  ; OP::return END
}
```

## TODO

### Refactor member function namespace/name mangling to all be within the module class.

Or figure out a way to make current solution work.

### Implement Algorithm for Building Order Of Operations Trees:

See description of algorithm in file:

`llvmcompiler/tree_builder/build_tree/operations_parser.py`

### Implement Struct Operators (Not started yet):

 - Operator functions will be prefixed with the `OPERATOR` keyword rather than `func`

 - Destructor operator to decide how to handle memory when out of scope

    All heap allocated values are collected by default.

```rust
struct StructName {
    OPERATOR destructor(self) {
        delete self.heap_allocated_attribute;
    }
}
```

### Major Rework of Garbage Collector And How Heap is Allocated (Done):

```py
{
    let test_md_array: [$[i32]] persist = [
        heap [0,1,2],
        heap [0,1,2],
        heap [0,1,2],
        heap [0,1,2],
        heap [0,1,2]
    ];


    # test_md_array's heap allocated members are freed here at the end of its scope if persist is not used.
    # all heap values become null
}
```

The heap keyword should prefix values instead of variables.  This means that the garbage collector will need to free those values once the memory goes out of scope.

### Implement Float Types For Operators (Not started yet)
